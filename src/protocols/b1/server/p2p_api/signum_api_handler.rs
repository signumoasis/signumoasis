use anyhow::Result;
use axum::{extract::State, response::IntoResponse, Json};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use surrealdb::syn::parse;

use crate::{
    common::ResponseError,
    protocols::b1::{B1Datastore, B1Settings},
};

use super::request_models::RequestType;

/// The primary handler function for requests to the BRS Client API. This function
/// will hand off all processing to other functions and serves only as a router and
/// to return the responses generated by other functions.
/// This is due to the non-HTTP-compliant nature of the B
#[tracing::instrument(skip_all)]
pub async fn signum_api_handler(
    State(datastore): State<B1Datastore>,
    State(settings): State<B1Settings>,
    Json(request_object): Json<RequestType>,
) -> Result<impl IntoResponse, ResponseError> {
    tracing::debug!("Request Object: {:#?}", &request_object);
    let _settings = settings;

    let mut result = match request_object.clone() {
        RequestType::AddPeers { peers } => serde_json::json!(format!("Adding peers: {:?}", peers)),
        RequestType::GetBlocksFromHeight(payload) => {
            serde_json::json!(format!(
                "Getting {} blocks from height {}",
                payload.num_blocks, payload.height
            ))
        }
        RequestType::GetCumulativeDifficulty => get_cumulative_difficulty().await?,
        RequestType::GetInfo(_payload) => serde_json::json!("Getting this node's info".to_owned()),
        RequestType::GetMilestoneBlockIds(_ids) => {
            serde_json::json!("Getting milestone block ids".to_owned())
        }
        RequestType::GetNextBlockIds(block_id) => {
            serde_json::json!(format!("Getting next block ids starting at {:?}", block_id))
        }
        RequestType::GetPeers => get_peers(datastore).await?,
        RequestType::GetNextBlocks(payload) => {
            serde_json::json!(format!("Getting next blocks from {}", payload.block_id))
        }
        RequestType::GetUnconfirmedTransactions => {
            serde_json::json!("Getting unconfirmed transactions".to_owned())
        }
        RequestType::ProcessBlock => todo!(),
        RequestType::ProcessTransactions => todo!(),
    };
    if let Some(map) = result.as_object_mut() {
        map.insert("requestProcessingTime".to_owned(), Value::Number(0.into()));
    } else {
        tracing::error!("Couldn't get result as mutable object")
    };
    Ok(Json(result))
}

#[tracing::instrument(skip_all)]
pub async fn get_peers(datastore: B1Datastore) -> Result<Value> {
    #[derive(Debug, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct GetPeersResponse {
        peers: Vec<String>,
        request_processing_time: u32,
    }

    let all_peers = datastore.client_api_all_peers().await?;

    let result = GetPeersResponse {
        peers: all_peers,
        request_processing_time: 0,
    };
    tracing::debug!("TheResult: {:#?}", &result);
    let json = serde_json::json!(result);
    Ok(json)
}
pub async fn get_cumulative_difficulty() -> Result<Value> {
    let value = serde_json::json!("Cumulative difficulty here".to_owned());
    Ok(value)
}
