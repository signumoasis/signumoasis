use anyhow::{Context, Result};
use axum::{extract::State, response::IntoResponse, Json};
use http::StatusCode;
use num_bigint::BigUint;
use serde_json::Value;

use crate::protocols::b1::{server::BRS_VERSION, B1Datastore, B1Settings};

use super::{outgoing_json::OutgoingJsonBuilder, request_models::RequestType};

/// The primary handler function for requests to the BRS Client API. This function
/// will hand off all processing to other functions and serves only as a router and
/// to return the responses generated by other functions.
/// This is due to the non-HTTP-compliant nature of the B
#[tracing::instrument(skip_all)]
pub async fn signum_api_handler(
    State(datastore): State<B1Datastore>,
    State(settings): State<B1Settings>,
    Json(request_object): Json<RequestType>,
) -> Result<impl IntoResponse, SignumApiError> {
    tracing::debug!("Request Object: {:#?}", &request_object);
    let _settings = settings;

    let result = match request_object.clone() {
        RequestType::AddPeers { peers } => return Err(SignumApiError::NotImplemented),
        RequestType::GetBlocksFromHeight(payload) => return Err(SignumApiError::NotImplemented),
        RequestType::GetCumulativeDifficulty => get_cumulative_difficulty().await?,
        RequestType::GetInfo(_payload) => return Err(SignumApiError::NotImplemented),
        RequestType::GetMilestoneBlockIds(_ids) => return Err(SignumApiError::NotImplemented),
        RequestType::GetNextBlockIds(block_id) => return Err(SignumApiError::NotImplemented),
        RequestType::GetPeers => get_peers(datastore).await?,
        RequestType::GetNextBlocks(payload) => return Err(SignumApiError::NotImplemented),
        RequestType::GetUnconfirmedTransactions => return Err(SignumApiError::NotImplemented),
        RequestType::ProcessBlock => return Err(SignumApiError::NotImplemented),
        RequestType::ProcessTransactions => return Err(SignumApiError::NotImplemented),
    };

    Ok(Json(result))
}

#[tracing::instrument(skip_all)]
pub async fn get_peers(datastore: B1Datastore) -> Result<Value, SignumApiError> {
    #[derive(Debug, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct GetPeersResponse {
        peers: Vec<String>,
        request_processing_time: u32,
    }

    let all_peers = datastore
        .p2p_api_all_peers()
        .await
        .context("unable to get all peers from database")
        .map_err(SignumApiError::UnexpectedError)?;

    let result = GetPeersResponse {
        peers: all_peers,
        request_processing_time: 0,
    };
    tracing::debug!("TheResult: {:#?}", &result);
    let json = serde_json::json!(result);
    Ok(json)
}
pub async fn get_cumulative_difficulty() -> Result<Value, SignumApiError> {
    // TODO: Pull the real cumulativeDifficulty information after the chain is working ad we have it
    let thebignumber = BigUint::parse_bytes(b"157919834588195404057", 10)
        .ok_or_else(|| anyhow::anyhow!("unable to parse BigUint"))?;

    let _value = serde_json::json!({
        "cumulativeDifficulty": thebignumber.to_string(),
        "blockchainHeight": 1391505u32
    });
    Err(SignumApiError::NotImplemented)
    //Ok(value)
}

#[derive(thiserror::Error)]
pub enum SignumApiError {
    #[error("Not implemented ")]
    NotImplemented,
    #[error(transparent)]
    UnexpectedError(#[from] anyhow::Error),
}

impl std::fmt::Debug for SignumApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        crate::error_chain_fmt(self, f)
    }
}

impl IntoResponse for SignumApiError {
    fn into_response(self) -> axum::response::Response {
        let (code, message) = match self {
            SignumApiError::NotImplemented => {
                (StatusCode::NOT_IMPLEMENTED, "not implemented".to_string())
            }
            SignumApiError::UnexpectedError(error) => {
                (StatusCode::INTERNAL_SERVER_ERROR, format!("{:?}", error))
            }
        };

        (code, message).into_response()
    }
}
