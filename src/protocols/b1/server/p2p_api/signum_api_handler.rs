use std::str::FromStr;

use axum::extract::State;

use crate::protocols::b1::B1Datastore;

#[derive(Debug)]
enum B1ClientApiRequestType {
    GetPeers,
}

impl FromStr for B1ClientApiRequestType {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s {
            "getPeers" => Self::GetPeers,
            _ => anyhow::bail!("unsupported request type"),
        })
    }
}

// /// The primary handler function for requests to the BRS Client API. This functino
// /// will hand off all processing to other functions and serves only as a router and
// /// to return the responses generated by other functions.
// /// This is due to the non-HTTP-compliant nature of the B
//#[tracing::instrument(skip_all)]
//pub async fn signum_api_handler(
//    State(datastore): State<B1Datastore>,
//    settings: Data<PeerToPeerSettings>,
//    request_object: Json<request_models::RequestType>,
//) -> Result<impl Responder, actix_web::Error> {
//    tracing::debug!("Request Object: {:#?}", &request_object);
//    let settings = settings.into_inner();
//
//    match request_object.0 {
//        request_models::RequestType::AddPeers { peers } => add_peers::add_peers_handler(peers),
//        request_models::RequestType::GetInfo(payload) => {
//            get_info::get_info_handler(payload, &settings)
//        }
//        request_models::RequestType::GetPeers {} => get_peers::get_peers_handler(),
//    }
//}
//
//#[tracing::instrument]
//pub async fn client_api_handler(
//    State(datastore): State<B1Datastore>,
//    Query(query): Query<HashMap<String, String>>,
//) -> Result<impl IntoResponse, ResponseError> {
//    tracing::debug!("query was: {:?}", &query);
//    let request_type = query
//        .get("requestType")
//        .ok_or_else(|| anyhow::anyhow!("requestType missing"))?
//        .parse::<B1ClientApiRequestType>()?;
//    tracing::debug!("Request type is: {:?}", &request_type);
//    let result = match request_type {
//        B1ClientApiRequestType::GetPeers => get_peers(datastore).await,
//    };
//    Ok(result)
//}
//
///// B1 client API. Gets the list of peers this node knows about.
//#[tracing::instrument]
//pub async fn get_peers(datastore: B1Datastore) -> Result<impl IntoResponse, ResponseError> {
//    #[derive(Debug, Serialize, Deserialize)]
//    #[serde(rename_all = "camelCase")]
//    struct GetPeersResponse {
//        peers: Vec<String>,
//        request_processing_time: u32,
//    }
//
//    let all_peers = datastore.client_api_all_peers().await?;
//
//    let result = GetPeersResponse {
//        peers: all_peers,
//        request_processing_time: 0,
//    };
//    tracing::debug!("TheResult: {:#?}", &result);
//    Ok(Json(result))
//}
