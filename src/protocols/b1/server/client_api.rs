use std::{collections::HashMap, str::FromStr};

use axum::{
    extract::{Query, State},
    response::IntoResponse,
    Json,
};
use serde::{Deserialize, Serialize};

use crate::common::ResponseError;

use super::B1Datastore;

/// The primary handler function for requests to the BRS Client API. This functino
/// will hand off all processing to other functions and serves only as a router and
/// to return the responses generated by other functions.
/// This is due to the non-HTTP-compliant nature of the B
#[tracing::instrument]
pub async fn client_api_handler(
    State(datastore): State<B1Datastore>,
    Query(query): Query<HashMap<String, String>>,
) -> Result<impl IntoResponse, ResponseError> {
    tracing::debug!("query string was: {:?}", &query);
    let request_type = query
        .get("requestType")
        .ok_or_else(|| anyhow::anyhow!("requestType missing"))?
        .parse::<B1ClientApiRequestType>()?;
    tracing::debug!("Request type is: {:?}", &request_type);
    let result = match request_type {
        B1ClientApiRequestType::GetPeers => get_peers(datastore).await,
    };
    Ok(result)
}

/// B1 client API. Gets the list of peers this node knows about.
#[tracing::instrument]
pub async fn get_peers(datastore: B1Datastore) -> Result<impl IntoResponse, ResponseError> {
    #[derive(Debug, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct GetPeersResponse {
        peers: Vec<String>,
        request_processing_time: u32,
    }

    let all_peers = datastore.client_api_all_peers().await?;

    let result = GetPeersResponse {
        peers: all_peers,
        request_processing_time: 0,
    };
    Ok(Json(result))
}

#[derive(Debug)]
enum B1ClientApiRequestType {
    GetPeers,
}

impl FromStr for B1ClientApiRequestType {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s {
            "getPeers" => Self::GetPeers,
            _ => anyhow::bail!("unsupported request type"),
        })
    }
}
